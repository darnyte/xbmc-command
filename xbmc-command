#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# simple XBMC command client.
#
# Copyright (C) 2013 Christoph GÃ¶ttschkes
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import argparse
import inspect
import json
import os
import socket
import sys
import time

class Rpc(object):

    def __init__(self, method = None):
        self.__method = method

    def __getattr__(self, key):
        return Rpc(self.__method + "." + key) if self.__method else Rpc(key)

    def __call__(self, *args, **kwargs):
        req = '{"jsonrpc":"2.0", "method":"%s", "params":' % (self.__method)
        if 'params' in kwargs:
          req += json.dumps(kwargs['params'])
        elif len(args) > 0:
          req += json.dumps(args[0])
        else:
          req += '{}'
        req += ', "id":"%s"}'
        return req % (str(kwargs['id'] if 'id' in kwargs else self.__method))

class CommandException(Exception):

  def __init__(self, msg):
    self.msg = msg

  def __str__(self):
    return self.msg

class Command(object):

  def __init__(self, xbmc, args):
    self.xbmc = xbmc
    self.args = args

  def send(self, msg):
    self.xbmc.send(bytearray(msg, 'utf-8'))

  def wait_for(self, request_id):
    start = time.time()

    decoder = json.JSONDecoder().raw_decode
    buffer = ""
    while True:
      if self.args.timeout > 0 and time.time() - start > self.args.timeout:
        break
      data = self.xbmc.recv(1024)
      if not data:
        return None
      data = data.decode('utf-8')
      buffer += data

      while True:
        j = None
        try:
          j, i = decoder(buffer)
          buffer = buffer[i:]
        except ValueError:
          break
        if j and 'id' in j and j['id'] == request_id:
          return j

    return None

  def get_active_player_id(self):
    to_send = Rpc().Player.GetActivePlayers()
    self.send(to_send)
    result = self.wait_for('Player.GetActivePlayers')
    if not result:
      raise CommandException('unable to receive active players')
    if len(result['result']) <= 0:
      return -1
    return result['result'][0]['playerid']

class youtube_command(Command):

  def __init__(self, xbmc, args):
    super(youtube_command, self).__init__(xbmc, args)

  def __call__(self):
    xbmc_file = 'plugin://plugin.video.youtube/?action=play_video&videoid=%s'
    xbmc_file = xbmc_file % self.args.id
    to_send = Rpc().Player.Open({'item':{'file':xbmc_file}})
    self.send(to_send)

  @staticmethod
  def add_to_argparse(subparsers):
    youtube = subparsers.add_parser('youtube', add_help=False,
        help='play a youtube video', description='Open a youtube video file.')
    youtube.set_defaults(command=youtube_command)

    youtube.add_argument('--id', dest='id', required=True,
        metavar='YOUTUBE_ID', help='the youtube video id')

    add_help_to_parser(youtube)

class prev_command(Command):

  def __init__(self, xbmc, args):
    super(prev_command, self).__init__(xbmc, args)

  def __call__(self):
    player_id = self.get_active_player_id()
    if player_id < 0:
      return

    to_send = Rpc().Player.GoTo({'playerid':player_id, 'to': 'previous'})
    self.send(to_send)

  @staticmethod
  def add_to_argparse(subparsers):
    pause_play = subparsers.add_parser('prev', add_help=False,
        help='go to the previous item in playlist',
        description='Go to the previous item in playlist.')
    pause_play.set_defaults(command=prev_command)

    add_help_to_parser(pause_play)

class next_command(Command):

  def __init__(self, xbmc, args):
    super(next_command, self).__init__(xbmc, args)

  def __call__(self):
    player_id = self.get_active_player_id()
    if player_id < 0:
      return
    to_send = Rpc().Player.GoTo({'playerid':player_id, 'to': 'next'})
    self.send(to_send)

  @staticmethod
  def add_to_argparse(subparsers):
    pause_play = subparsers.add_parser('next', add_help=False,
        help='go to the next item in playlist',
        description='Go to the next item in playlist.')
    pause_play.set_defaults(command=next_command)

    add_help_to_parser(pause_play)

class play_pause_command(Command):

  def __init__(self, xbmc, args):
    super(play_pause_command, self).__init__(xbmc, args)

  def __call__(self):
    player_id = self.get_active_player_id()
    if player_id < 0:
      return

    to_send = Rpc().Player.PlayPause({'playerid': player_id})
    self.send(to_send)

  @staticmethod
  def add_to_argparse(subparsers):
    pause_play = subparsers.add_parser('play-pause', add_help=False,
        help='toggle play/pause', description='Toggle play/pause.')
    pause_play.set_defaults(command=play_pause_command)

    add_help_to_parser(pause_play)

class mute_command(Command):

  def __init__(self, xbmc, args):
    super(mute_command, self).__init__(xbmc, args)

  def __call__(self):
    self.send(Rpc().Application.SetMute({'mute': 'toggle'}))

  @staticmethod
  def add_to_argparse(subparsers):
    mute = subparsers.add_parser('mute', add_help=False,
        help='toggle mute', description='Toggle mute.')
    mute.set_defaults(command=mute_command)

    add_help_to_parser(mute)

class volume_command(Command):

  def __init__(self, xbmc, args):
    super(volume_command, self).__init__(xbmc, args)

  def __call__(self):
    if self.args.decrement:
      vol = 'decrement'
    elif self.args.increment:
      vol = 'increment'
    else:
      vol = self.args.set

    self.send(Rpc().Application.SetVolume({'volume':vol}))

  @staticmethod
  def add_to_argparse(subparsers):
    volume = subparsers.add_parser('volume', add_help=False,
        help='set or increment/decrement the volume',
        description='Set or increment/decrement the volume.')
    volume.set_defaults(command=volume_command)

    volume_group = volume.add_mutually_exclusive_group(required=True)

    volume_group.add_argument('--increment', dest='increment',
        action='store_true', default=False,
        help='increment the volume')

    volume_group.add_argument('--decrement', dest='decrement',
        action='store_true', default=False,
        help='decrement the volume')

    volume_group.add_argument('--set', dest='set',
        type=parse_range_zero_to_hundred, metavar='VOLUME',
        help='set the volume to VOLUME (range 0-100)')

    add_help_to_parser(volume)

def main(args):
  xbmc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  xbmc.settimeout(args.timeout if args.timeout else None)

  try:
    xbmc.connect((args.host, args.port))
  except:
    sys.exit("Unable to connect to host %s:%s" % (args.host, args.port))

  cmd = args.command(xbmc, args)
  try:
    cmd()
  except CommandException as e:
    sys.exit(e.msg)
  finally:
    xbmc.close()

def add_help_to_parser(parser):
  parser.add_argument('--help', action='help',
      help='show this help message and exit')

def parse_int(string):
  try:
    return int(string)
  except ValueError:
    raise argparse.ArgumentTypeError("invalid int value: '%s'" % string)

def parse_range_zero_to_hundred(string):
  string = parse_int(string)
  if string < 0 or string > 100:
    raise argparse.ArgumentTypeError(
            "int value %d out of range (0-100)" % string)
  return string

def parse_positive_or_zero_int(string):
  string = parse_int(string)
  if string < 0:
    raise argparse.ArgumentTypeError("int value is negative: %d" %string)
  return string

if __name__ == '__main__':
  parser = argparse.ArgumentParser(
      description="",
      prog=os.path.basename(sys.argv[0]), add_help=False)

  parser.add_argument('--host', dest='host', metavar='HOST', required=True,
      help='connect to server at host')

  parser.add_argument('--port', dest='port', metavar='PORT', required=True,
      type=int, help='connect to server at port')

  parser.add_argument('--timeout', dest='timeout', metavar='SEC',
      type=parse_positive_or_zero_int, default=5, help='wait SEC till timeout')

  parser.add_argument('--help', action='help',
      help='show this help message and exit')

  parser.add_argument('--version', action='version',
      version='%(prog)s 1.0.0')

  subparsers = parser.add_subparsers(
      title='commands', description='valid XBMC commands')

  for name, obj in inspect.getmembers(sys.modules[__name__]):
    if hasattr(obj, '__bases__') and Command in obj.__bases__:
      obj.add_to_argparse(subparsers)

  main(parser.parse_args())

# vim: ft=python ts=2 sts=2 sw=2 et:
